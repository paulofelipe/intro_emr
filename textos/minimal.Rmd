---
title: "Equilíbrio Geral Computável: Implementando o MINIMAL no R"
author: "Paulo Felipe Alencar"
date: "05/06/2019"
classoption: twoside
output: 
  pdf_document:
    number_section: true
    citation_package: natbib
    highlight: default
    toc: true
    toc_depth: 4
    includes:
      in_header: header.tex
bibliography: referencias.bib
lang: pt-br
fontsize: 11pt
subparagraph: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(kableExtra)
```

\clearpage
\begin{abstract}
Este documento tem o objetivo de discutir a implementação de um modelo de equilíbrio geral simples no R usando o pacote `emr`. Como exemplo, utiliza-se o MINIMAL que é um modelo desenvolvido com propósitos educacionais pelos criadores do GEMPACK. Este modelo é de um único país com múltiplos setores, múltiplas fontes de demanda e comércio internacional.
\end{abstract}

# Introdução

O MINIMAL^[https://www.copsmodels.com/minimal.htm] (\cite{horridge_2001}) é um modelo de equilíbrio geral simplificado utilizado em cursos introdutórios do GEMPACK. A partir desse modelo, é possível deixar claro como a teoria microeconômica do consumidor e do produtor podem ser combinadas para a construção de um modelo de equilíbrio geral. 

Este modelo considera 7 setores, um investidor agregado, um agente representativo das famílias, exportações agregadas e o governo. Cada produto pode ser obtido a partir de fontes domésticas ou importadas.

# Estruturas de Modelo para o Pacote `emr`

A definição dos modelos segue a lógica discutida em [A simple structure for CGE models](https://jgea.org/resources/download/6539.pdf) by Xiao-guang Zhang. 

```{r, fig.cap="Estrutura das variáveis e das equações (Zhang, 2013)", fig.pos="H",echo=FALSE,fig.align='center'}
knitr::include_graphics('structure_var_eq.png', dpi = 200)
```

Nessa abordagem, as variáveis exógenas e endógenas serão classificadas em dois tipos: definidas ou não-definidas. As variáveis exógenas, por definição, são definidas. As endógenas pode ser dos dois tipos. As variáveis definidas são aquelas que podem ser construídas a partir dos valores das demais variáveis, das chamadas equação de definição. Já as não-definidas são aquelas que os valores serão definidos a partir de condições de equilíbrio de mercado (MCCs). 



## Exemplo: Oferta e Demanda 

# Implementando o MINIMAL no R

## Dados para o Modelo

Os dados para o modelo são esquematizados conforme a Figura \ref{model_database}. O esquema é similar ao de uma matriz de insumo produto, na qual os elementos das linhas vendem para os elementos das colunas. 

```{r, fig.cap="Base de Dados para o Minimal(\\cite{horridge_2001}\\label{model_database})", echo=FALSE, fig.pos='h',fig.align='center'}
knitr::include_graphics('minimal_database.PNG', dpi = 150)
```

Fica claro na \ref{model_database} que existem duas fontes (*sources*) de fornecimento de produtos: doméstica e importada. Esse produtos são demandados pelos $I$ setores produtores, pelos investidores, pelas famílias, pelas exportações^[O fornecimento de produtos importados para exportação é igual a zero.] e pelo governo. As somas das linhas para produtos (*commodities*) domésticos ou importados serão denominadas de vendas (*sales*).

Adicionalmente, os fatores trabalhos e capital são demandados pelos produtores, e há uma taxação sobre a produção. Por fim, independente do demandante, existe um imposto de importação por produto. O valor arrecadado de imposto de importação será único por produto, o que resulta em uma única taxa de importação por produto.

A tabela apresentada na Figura \ref{dados_australia} detalha um conjunto de valores para a Austrália a partir de dados de 1986-1987. Os valores estão a preços dos produtores. Ou seja, inclui qualquer imposto indireto que possa ter sido aplicada àquele fluxo. Para cada setor produtor, a sua produção (soma da respectiva coluna) tem que ser igual às suas vendas (soma da respectiva linha). Por exemplo, a produção do setor Agricultura-Mineração (AgricMining) foi igual 45.730, que é o mesmo valor de suas vendas.

Para as importações de produtos manufaturados (Manufacture), foi recolhido o montante de 5.787. O valor total importado desses produtos foi de 42.087 (este valor já inclui o imposto de importação), o que implica em uma taxa de importação de 15,94%^[5787/(42087 - 5787).].

```{r, echo=FALSE, out.extra='angle=90', fig.cap="Base de Dados para Austrália (Milhões 1986-1987)\\label{dados_australia}",fig.align='center'}
knitr::include_graphics('minimal_database_australia.PNG', auto_pdf = TRUE, dpi = 150)
```


## Implementação

### Passos Iniciais

Inicialmente, é preciso carregar o pacote `emr`:

```{r}
library(emr)
# Carregar o tidyverse para manipulação dos dados
library(tidyverse)
```

Adicionalmente, também é necessário ler os dados que servirão de base para o modelo. Os dados foram exportados do formato HAR do GEMPACK para csv. Nessa conversão, as diversas tabelas são empilhadas em um único csv, sendo separadas por uma linha denominada de *HEADER*.

Dessa forma, vamos inicialmente identificar os *headers*:

```{r}
minimal_headers <- read_lines('../dados/minimal.csv')

minimal_headers[str_detect(minimal_headers, "Header")]
```

A Tabela \ref{tab:headers_pos} detalha em quais linhas as tabelas se iniciam de fato e quantas linhas de dados existem em cada tabela. Por exemplo, a tabela `USE`, que contém os dados de uso por produto, origem e usuário, inicia-se na linha 2 e encerra na linha 156, sendo 154 linhas de dados e uma com os títulos de cada coluna. Para, ler essa tabela, podemos executar o seguinte código:

```{r}
USE <- read_csv(
  file = '../dados/minimal.csv',
  skip = 1,
  n_max = 154,
  col_types = 'cccd'
)

head(USE)
```

```{r headers_pos, echo=FALSE}
headers_names <- minimal_headers[str_detect(minimal_headers, "Header")] %>%
  str_split(" ") %>%
  map_chr(~{.x[2]}) %>%
  str_remove(",")

headers <- which(str_detect(minimal_headers, "Header"))

data.frame(
  names = headers_names,
  inicio = headers + 1,
  final = c(headers[-1] - 1, length(minimal_headers))
) %>% 
  mutate(num_linhas = final - inicio) %>% 
  kable(
    booktabs = TRUE,
    align = 'lrrr',
    linesep = "",
    col.names = c("Nome", "Início", "Fim", "Nº de Linhas"),
    caption = "Posição de Cada Header no Arquivo minimal.csv"
  ) %>% 
  kable_styling(position = "center", latex_options = "hold_position") %>% 
  column_spec(1, width = "3em") %>% 
  column_spec(2:4, width = "5em")
```

As demais tabelas serão importadas quando necessárias.

### Conjuntos (*Sets*)

Aqui, iremos definir os conjuntos de índices que são utilizados pelas variáveis do modelo. Por exemplo, a variável de produção é definida por produto (*commodity*) pertencente ao conjunto COM, que é composto pela descrição de todos os produtos.

Para implementação do modelo, precisaos de uma lista nomeada `sets`, na qual cada elemento recebe o nome do conjunto e seus possíveis valores.

Abaixo listamos todos os conjuntos:

* IND: indústrias;
* SRC: origem (doméstica ou importada);
* COM: produtos;
* USER: usuários (fontes de demanda);
* IMPUSER: usuários que demandam produtos importados;
* FINALUSER: usuários que compõem a absorção final da economia;
* FAC: fatores primários (capital e trabalho). 

Abaixo, o código para criar os conjuntos.

```{r}
IND <- c("AgricMining", "Manufacture", "Utilities", "Construction", 
         "TradeTranspt", "FinanProprty", "Services")

COM <- c("AgricMining", "Manufacture", "Utilities", "Construction", 
         "TradeTranspt", "FinanProprty", "Services")

SRC <- c("dom", "imp")

USER <- c("AgricMining", "Manufacture", "Utilities", "Construction", 
          "TradeTranspt", "FinanProprty", "Services", "Investment", 
          "Households", "Government", "Exports")

IMPUSER <- c("AgricMining", "Manufacture", "Utilities", "Construction", 
             "TradeTranspt", "FinanProprty", "Services", "Investment", 
             "Households", "Government")

FINALUSER <- setdiff(USER, IND)

FAC <- c("Labour", "Capital")

sets <- list(
  IND = IND,
  COM = COM,
  SRC = SRC,
  USER = USER,
  IMPUSER = IMPUSER,
  FINALUSER = FINALUSER,
  FAC = FAC
)
```

```{r,echo=FALSE, eval=FALSE}
lapply(sets, function(x) paste0(x, collapse = ", ")) %>%
  data.frame(stringsAsFactors = FALSE) %>% 
  gather(key = set, value = value) %>% 
  kable(
    booktabs = TRUE,
    align = 'll',
    col.names = c("Conjunto", "Valores"),
  ) %>% 
  kable_styling() %>% 
  column_spec(2, width = '40em')
```

### Preços

Inicialmente, vamos definir os preços dos produtos $c \in \text{COM}$ fornecidos pelas fontes $s \in \text{SRC}$:

\begin{equation}\label{e_p}
P_{cs} =
  \begin{cases}
    \text{P1TOT}_c \times \text{PTX}_{c}       & \quad \text{se } s = \text{dom}\\
    \text{PWORLD}_c \times \phi \times \text{mtx}_c       & \quad \text{se } s = \text{imp},
  \end{cases}
\end{equation}
em que $P_{cs}$ é o preço do produto $c$ de origem $s$, $\text{P1TOT}_{c}$ é o custo (marginal) de produção do produto $c$, $\text{PTX}_{c}$ é o poder da imposto sobre a produção (1 + imposto sobre a produção), $\text{PWORLD}_c$ é o preço internacional do produto $c$, $\phi$ é a taxa de câmbio^[A taxa de câmbio é usada como numerário no modelo] e $\text{mtx}_c$ é o poder da tarifa sobre a importação do produto $c$.

No GEMPACK, as equações são reescritas utilizando a forma de variação percentual. Aqui, vamos utilizar a chamada *exact-hat algebra*. As variáveis serão reescritas em variações. Assim, por exemplo, denotamos a variação exata de uma variável $x$ como $\hat{x} = \frac{x^\prime}{x}$, em que $x$ é o valor inicial e $x^\prime$ é o valor no novo equilíbrio.

Assim, iremos reescrever \ref{e_p} como:
\begin{equation}\label{e_p_hat}
\hat{P}_{cs} =
  \begin{cases}
    \hat{\text{P1TOT}}_c \times \hat{\text{PTX}}_{c}       & \quad \text{se } s = \text{dom}\\
    \hat{\text{PWORLD}}_c \times \hat{\phi} \times \hat{\text{mtx}}_c       & \quad \text{se } s = \text{imp},
  \end{cases}
\end{equation}

Adicionalmente, ao consumir o bem $c$ de duas diferentes fontes (doméstica e importada), os demandantes estão consumindo um bem composto com preço $P^s_{cu}$ definido como:

$$\hat{P}^s_{cu} = \sum_{s\in SRC}\text{SRCSHARE}_{cus} \hat{P}_{cs}, \quad c \in \text{COM}, u \in \text{IMPUSER}$$
em que $\text{SRCSHARE}_{cus}$ é participação da origem $s$ no dispêndio do usuário $u$ em produtos $c$.


Antes de começarmos a definir os parâmetros, as variáveis e as equações, precisamos definir as listas que guardarão esses componentes do modelo:

```{r}
params <- list()
variables <- list()
equations <- list()
```

Agora, vamos começar a definir os parâmetros das equações acima.

```{r}
params[["PTX"]] <- create_param(
  value = 1,
  indexes = sets['IND'],
  desc = "Variação no poder do imposto sobre a produção"
)

params[["PWORLD"]] <- create_param(
  value = 1,
  indexes = sets['COM'],
  desc = "Variação no preço internacional do produto c"
)

params[["PHI"]] <- create_param(
  value = 1,
  indexes = "PHI",
  desc = "Variação na taxa de câmbio"
)

params[["MTX"]] <- create_param(
  value = 1,
  indexes = sets['COM'],
  desc = "Variação no poder da tarifa de importação do produto c"
)

SRCSHARE <- USE %>% 
  filter(USER %in% IMPUSER) %>% 
  group_by(COM, USER) %>% 
  mutate(SRCSHR = Value/sum(Value),
         SRCSHR = ifelse(is.nan(SRCSHR), 0, SRCSHR)) %>% 
  select(COM, SRC, USER, SRCSHR)

params[["SRCSHARE"]] <- create_param(
  value = SRCSHARE,
  indexes = sets[c("COM", "SRC", "IMPUSER")],
  desc = "Participação da origem s no consumo do produto c pelo usurário u"
)
```

Consideramos que $\hat{\text{PWORLD}}_c$ é um parâmetro, ou seja, é exógeno. Isto significa que foi assumido que os preços internacionais são dados, a demanda do país analisado não tem poder para alterar os preços internacionais. 

O segundo passo para esse bloco é definir as variáveis. Iremos definir as variáveis $\hat{P}_{cs}$ e $\hat{P}^s_{cu}$. A variável $\hat{\text{P1TOT}}$ não será definida agora por dois motivos, pois não temos uma equação para definir o seu valor. Veremos adiante que o valor de $\hat{\text{P1TOT}}$ é encontrada a partir de um equação de equilíbrio de mercado (`mcc`) que define que $\hat{\text{P1TOT}}$ tem que ser igual à variação do custo de produção (lucro zero).

```{r}
variables[["p"]] <- create_variable(
  value = 1,
  indexes = sets[c("COM","SRC")],
  type = "defined",
  desc = "Variação no preço do produto c de origem s"
)

variables[["p_s"]] <- create_variable(
  value = 1,
  indexes = sets[c("COM", "IMPUSER")],
  type = "defined",
  desc = "Variação no índice de preço do bem composto c para o usuário u"
)


```

Por último, iremos definir as equações.

```{r}
equations[["E_p"]] <- create_equation(
  'if(s == "dom"){
    p[c,s] = p1tot[c] * PTX[c]
  } else {
    p[c,s] = PWORLD[c] * PHI * MTX[c]
  }',
  indexes = c("c in COM", "s in SRC"),
  type = "defining",
  desc = "Variação no preço do produto c de origem s"
)

equations[["E_p_s"]] <- create_equation(
  'p_s[c,u] = sum(SRCSHARE[c,,u] * p[c,])',
  indexes = c('c in COM', 'u in IMPUSER'),
  type = "defining",
  desc = "Variação no índice de preço do bem composto c para o usuário u"
)
```

Note que para o somatório usamos a função `sum()` do R. Além disso, tem-se que SRCSHARE tem 3 dimensões e queremos somar em relação a origem, que é a segunda dimensão. Então, omitimos o índice de origem (SRC) e a soma ocorrerá nessa dimensão.

Além dos preços para os produtos $c$, existem os mercados de trabalho (*labor*) e de capital que possuem seus respectivos preços, $\text{P1LAB}_i$ (salário) e $\text{P1CAP}_i$ (remuneração do capital). Note que, inicialmente, esses preços estão indexados à indústria que utiliza o fator de produção. Isto ocorre quando assumimos que o fator de produção é específico da indústria. Se o fator de produção tem mobilidade entre os setores, haverá um único preço para o fator de produção e o índice $i$ será removido. Isso dependerá do fechamento que será escolhido.

Além desses preços, o modelo considera índices de preços da cesta de consumos do investimento (P2TOT), das famílias (P3TOT) e do governo (P5TOT). Estes índices serão posrteriormente definidos dentro do seu respectivo bloco.

### Produção

A estrutura de produção utilizada no minimal é apresentada na Figura ... A estrutura adotada considera um primeiro nível em que o produtor demanda bens intermediários (*commodities*) e o fator primário, que é uma combinação de capital e trabalho. É assumida uma tecnologia do tipo Leontief. Dessa forma, pode-se definir o primeiro nível da produção como:
\begin{equation}\label{e_x1tot}
\text{X1TOT}_i = \min\left\{\frac{X_{c \{c~\in~\text{COM}\}i}}{A_{c\{c~\in~ \text{COM}\}i}}, \frac{\text{X1PRIM}_i}{A\text{1PRIM}_{i}}\right\}, ~ i \in \text{IND},
\end{equation}
em que $\text{X1TOT}_i$ é a produção total da $i$-ésima indústria, $X_{ci}$ é a demanda pelo produto $c$ pela indústria $i$ e $\text{X1PRIM}_i$ é a demanda por fatores primários pela indústria $i$. $A_{ci}$ e $A\text{1PRIM}$ podem ser entendidos como coeficientes técnicos da matriz de insumo-produto. Isto é, necessita-se $A_{ci}$ unidades do produto $c$ para se produzir uma unidade de $i$.

Para essa tecnologia, tem-se as seguintes funções de demanda:

- Demanda por bens intermediários (compostos)^[Os bens intermediários compostos são uma composição entre produtos domésticos e importados.]:
$$X_{ci} = A_{ci} \times \text{X1TOT}_i, ~i \in \text{IND},~c \in \text{COM}$$

- Demanda por valor adicionado:
$$\text{X1PRIM}_i = A\text{1PRIM}_{i}\times \text{X1TOT}_i$$

Essas equações, facilmente, podem ser reescritas em variações exatas:

- Demanda por bens intermediários:
$$\hat{X}_{ci} = \hat{A}_{ci}\times \hat{\text{X1TOT}}_i, ~i \in \text{IND},~c \in \text{COM}$$


- Demanda por valor adicionado:
$$\hat{\text{X1PRIM}}_i = \hat{\text{A1PRIM}}_i \times \hat{\text{X1TOT}}_i$$


Na sequência, vamos definir os parâmetros $\hat{A}_{ci}$ e $\hat{\text{A1PRIM}}_i$. Como estamos usando em variação, o valor inicial desses parâmetros é igual a 1.

```{r}
params[["A"]] <- create_param(
  value = 1,
  indexes = sets[c('COM', 'IND')],
  desc = "Variação do coeficiente técnico para o produto c usado pela indústria i"
)

params[["A1PRIM"]] <- create_param(
  value = 1,
  indexes = sets['IND'],
  desc = "Variação do coeficiente técnico para o fator primário usado pela indústria i"
)

```

Agora, vamos definir as variáveis $\hat{X}_{ci}$ (uso do produto composto $c$ pela indústria $i$) e $\hat{\text{X1PRIM}}_i$ (uso do fator primário composto). Aqui, existe um detalhe, o uso do produto $c$ pode ser feito pelas indústrias ou pelos demais usuários de demandam importações (IMPUSER). Dessa forma, na definição da variável $\hat{X}_{ci}$, vamos utilizar o conjunto IMPUSER ao invés do conjunto IND. Deixando mais claro, iremos definir

$$ \hat{X}_{cu},~ c \in \text{COM}, u \in \text{IMPUSER} $$
\[ \hat{X}_{cu} =
  \begin{cases}
    \hat{X}_{ci}       & \quad \text{se } u \in \text{IND}\\
    \hat{X}_{c,\text{HH}}       & \quad \text{se } u = \text{Households}\\
    \hat{X}_{c,\text{GOV}}       & \quad \text{se } u = \text{Governement}\\
    \hat{X}_{c,\text{INV}}       & \quad \text{se } u = \text{Investment}
  \end{cases}
\]


Ambas as variáveis são definidas, pois possuem equações que definem os seus valores.

```{r}
# chamamos de x de x_s (composto de várias sources s)
variables[["x_s"]] <- create_variable(
  value = 1,
  indexes = sets[c("COM", "IMPUSER")],
  type = "defined",
  desc = "Variação no uso do composto c por impuser"
)

variables[["x1prim"]] <- create_variable(
  value = 1,
  indexes = sets[c('IND')],
  type = "defined",
  desc = "Uso do fator primário composto por indústria"
)
```

Finalmente, iremos definir as equações. Note que temos a equação de uso para o produto composto c para os usuários industriais. Assim, iremos utilizar o índice `i in IND` ($i \in \text{IND}$).

```{r}
equations[["E_x_s_ind"]] <- create_equation(
  'x_s[c,i] = A[c,i] * x1tot[i]',
  indexes = c('c in COM', 'i in IND'),
  type = "defining",
  desc = "Variação do uso do composto c por indústria"
)
```


```{r}
equations[["E_x1prim"]] <- create_equation(
  'x1prim[i] = a1prim[i] * x1tot[i]',
  indexes = 'i in IND',
  type = "defining",
  desc = "Uso do fator primário composto por indústria"
)
```

Perceba que ainda não especificamos a variável $\hat{\text{X1TOT}}_i$. Ela será especificada em momento oportuno, mas vale antecipar que essa variável é do tipo `mcc`. Por quê? Perceba que, na Equação \ref{e_x1tot}, $\text{X1TOT}_i$ é função dos usos de bens intermediários e fatores primários. No entanto, a quantidade demandada desses bense fatores dependem de $\text{X1TOT}$. Dessa forma, $\text{X1TOT}$ não pode ser definida. Precisaremos de uma condição de equilibrio de mercado para encontrar o seu valor no novo equilíbrio. Isto será feito posteriormente.

Adicionalmente, por enquanto, não entraremos nos detalhes sobre a demanda no segundo nível (escolha entre bens domésticos e importados), tendo em vista que a forma da demanda é comum independente do usuário (indústrias, família, governo etc.).

### Famílias

Para as famílias, que serão representadas como HH, assume-se um agente representativo com preferências do tipo Cobb-Douglas sobre um conjunto de produtos (compostos) e uma restrição orçamentária. Isto é:
$$U = \prod_{c \in \text{COM}}X_{c,\text{HH}}^{\alpha_c}$$
$$s.a. \sum_{c\in \text{COM}} P_{c,\text{HH}} X_{c,\text{HH}} = \text{W3TOT},$$
em que $X_{c,\text{HH}}$ é quantidade demandada do bem composto $c$ pelas famílias (HH), $P_{c,\text{HH}}$ é o índice de preço do bem composto $c$ para as famílias e $\text{W3TOT}$ é renda nominal das famílias. Adicionalmente, $\sum_{c \in \text{COM}} \alpha_c = 1$.

Para esse tipo de preferência, sabe-se que, a partir da maximização de utilidade do consumidor, que a função de demanda ótima é:
$$X_{c,\text{HH}} = \alpha_c \frac{\text{W3TOT}}{P_{c,\text{HH}}},~ c \in \text{COM}.$$

Em variações, a demanda das famílias é escrita da seguinte forma:
$$\hat{X}_{c,\text{HH}} =  \frac{\hat{\text{W3TOT}}}{\hat{P}_{c,\text{HH}}}, ~ c \in \text{COM}.$$

Por fim, definimos o dispêndio real das famílias ($\text{X3TOT}$) como:
$$\hat{\text{X3TOT}} = \frac{\hat{\text{W3TOT}}}{\hat{\text{P3TOT}}},$$
em que $\text{P3TOT}$ é o índice de preços associado à cesta de consumo das famílias. O índice $\text{P3TOT}$ é uma média ponderada dos preços de cada bem composto $c$ para as famílias:
$$\text{P3TOT} = \sum_{c \in \text{COM}} \text{SHARE}_{c,\text{HH}} P_{c,\text{HH}}.$$ 
em que $\text{SHARE}_{c,\text{HH}}$ é a participação do bem $c$ no dispêndio das famílias.

Especificado a estrutura das famílias no modelo, vamos definir, primeiramente, o parâmetro $\text{SHARE}_{c,\text{HH}}$.

```{r}
# calcula os shares
SHARE_HH <- USE %>% 
  filter(USER == "Households") %>% 
  group_by(COM) %>% 
  summarise(Value = sum(Value)) %>% 
  mutate(SHARE = Value/sum(Value)) %>% 
  select(COM, SHARE)

params[["SHARE_HH"]] <- create_param(
  value = SHARE_HH,
  indexes = sets['COM'],
  desc = "Participação do bem c no dispêndio das famílias"
)
```

No fechamento do modelo que será adotado, o dispêndio real das famílias ($\hat{\text{X3TOT}}$) será exógeno. Portanto, o definiremos como um parâmetro do modelo.

```{r}
params[["X3TOT"]] <- create_param(
  value = 1,
  indexes = "X3TOT",
  desc = "Variação no dispêndio real das famílias"
)
```

Com essa definição, temos que:
$$\hat{\text{W3TOT}} = \hat{\text{X3TOT}} \times \hat{\text{P3TOT}}.$$
Isto é, a variação da renda das famílias tem que ser igual a variação do dispêndio real vezes a variação dos preços para as famílias.

Lembrando que a variável $\hat{X}_{c,\text{HH}}$ já está incluída na variável `x_s`, vamos definir as demais variáveis desse bloco:

```{r}
variables[["w3tot"]] <- create_variable(
  value = 1,
  indexes = "w3tot",
  type = "defined",
  desc = "Variação da renda nominal das famílias"
)

variables[["p3tot"]] <- create_variable(
  value = 1,
  indexes = "p3tot",
  type = "defined",
  desc = "Variação no índice de preços das famílias"
)
```

Finalmente, vamos definir as equações:

```{r}
equations[["E_x_s_hh"]] <- create_equation(
  'x_s[c, "Households"] = w3tot/p_s[c, "Households"]',
  indexes = c('c in COM'),
  type = "defining",
  desc = "Variação do uso do composto c pelas famílias"
)

equations[["E_w3tot"]] <- create_equation(
  'w3tot = X3TOT * p3tot',
  type = "defining",
  desc = "Variação na renda (dispêndio) nominal das família"
)

equations[["E_p3tot"]] <- create_equation(
  'p3tot = sum(SHARE_HH[] * p_s[,"Households"])',
  type = "defining",
  desc = "Variação do índice de preços das famílias"
)
```


### Investimento e Governo

No MINIMAL, não é assumida nenhuma estrutura específica para o dispêndio em investimento ou do governo. Será assumido, que essas duas fontes de demandas são exógenas. Ou seja, $\hat{X}_{c,\text{INV}} = 1$ e $\hat{X}_{c,\text{GOV}} = 1$. Portanto, iremos apenas defini-los como parâmetros, que poderão ser utilizados posteriormente como fontes de choques do modelo.

```{r}
params[["X_S_INV"]] <- create_param(
  value = 1,
  indexes = sets["COM"],
  desc = "Variação na demanda de investimento por produto c"
)

params[["X_S_GOV"]] <- create_param(
  value = 1,
  indexes = sets["COM"],
  desc = "Variação na demanda do governo por produto c"
)

```

Também definimos as equações que capturarão esses choques.

```{r}
equations[["E_x_s_inv"]] <- create_equation(
  'x_s[c, "Investment"] = X_S_INV[c]',
  indexes = 'c in COM',
  type = "defining",
  desc = "Variação no uso do composto c para investimento"
)

equations[["E_x_s_gov"]] <- create_equation(
  'x_s[c, "Government"] = X_S_GOV[c]',
  indexes = 'c in COM',
  type = "defining",
  desc = "Variação no uso do composto c pelo governo"
)
```


### Demanda de segundo nível entre bens domésticos e importados

Até o momento, apresentamos a demanda^[O componente de exportação demanda apenas o bem doméstico.] das indústrias, das famílias, do governo e do investimento pelos bens compostos. Nessa parte, vamos definir a demanda do nível inferior. Nesse nível, o consumidor escolhe alocar o seu consumo total entre o produto doméstico e o produto importado.

É assumida uma função de agregação CES, com elasticidade de substituição $\sigma_i$, que combina os produtos domésticos e importados. Nesse caso, a variação na demanda por cada produto, por fonte e por usuário, $\hat{X}_{csu}$, é dada pela seguinte função de demanda:
\begin{equation}\label{e_x}
\hat{X}_{csu} = \left(\frac{\hat{P}_{cs}}{\hat{P}_{cu}}\right)^{-\sigma_i} \hat{X}^s_{cu}, \quad c \in \text{COM},~s \in \text{SRC},~s \in \text{IMPUSER}
\end{equation}
em que $\hat{P}_{cs}$ é a variação do preço do produto $c$ fornecido pela fonte $s$. Já $\hat{P}_{cu}$ é o preço médio (índice de preço) do produto $c$ para o usuário $u$. 

Nesse bloco, precisamos criar o parâmetro $\sigma_i$, que é a também chamado de elasticidade de Armington. Os valores dessas elasticidades estão no *header* `ARM`. Usamos o código abaixo para importar essa tabela.

```{r}
ARM <- read_csv(
  file = '../dados/minimal.csv',
  skip = 191,
  n_max = 7,
  col_types = 'cd'
)

ARM
```

Então, podemo criar este parâmetro.

```{r}
params[["SIGMA"]] <- create_param(
  value = ARM,
  indexes = sets[c("COM")],
  desc = "Elasticidade de Armington"
)
```

Por fim, define-se a variável $\hat{X}_{csu}$ e a equação para os usuários pertencentes ao conjunto IMPUSER.

```{r}
variables[["x"]] <- create_variable(
  value = 1,
  indexes = sets[c("COM","SRC","USER")],
  type = "defined",
  desc = "Demand by commodity, source and user"
)

equations[["E_x_impuser"]] <- create_equation(
  'x[c,s,u] = x_s[c,u]*(p[c,s]/p_s[c,u])^(-SIGMA[c])',
  indexes = c('c in COM', 's in SRC', 'u in IMPUSER'),
  type = "defining",
  desc = "Demand by commodity, source and impuser"
)
```

Perceba que a variável foi definida para todos os usuários. No entanto, na Equação \ref{e_x}, está definida equação para $u \in \text{IMPUSER}$. Isto deve-se ao fato de que a demanda para o usuário *Exports* será definida de outra forma.

### Exportações

Para as exportações, é assumida uma função de elasticidade constante com parâmetro $\text{EXP\_ELAST}_c$ para o produto $c$. A demanda externa pelo produto doméstico depende do preço relativo entre o preço doméstico e o preço internacional daquele produto:
$$\hat{X}_{c~dom~exp} = \hat{F4Q}_c \left(\frac{\hat{P}_{c~dom}}{\hat{\phi}~\hat{\text{PWORLD}}}\right)^{-\text{EXP ELAST}_c}, \quad c \in \text{COM},$$
em que $\hat{F4Q}_c$ é um *shift* na demanda externa.

Abaixo, definimos este bloco.

```{r}
EXP_ELAST <- read_csv(
  file = '../dados/minimal.csv',
  skip = 209,
  n_max = 7,
  col_types = 'cd'
)

params[["EXP_ELAST"]] <- create_param(
  value = EXP_ELAST,
  indexes = sets["COM"],
  desc = "Elasticidade da demanda por exportações"
)

params[["F4Q"]] <- create_param(
  value = 1,
  indexes = sets[c("COM")],
  desc = "Shift na demanda externa para o produto c"
)

equations[["E_x_exp"]] <- create_equation(
  'x[c,"dom","Exports"] = F4Q[c]*(p[c,"dom"]/(PHI*PWORLD[c]))^(-EXP_ELAST[c])',
  indexes = 'c in COM',
  type = "defining",
  desc = "Variação das exportações do produto c"
)

```


### Demanda por Fatores Primários

Na parte da produção, vimos como cada indústria define a quantidade de fator primário que será utilizada para atingir uma determinada produção. Todavia, cada indústria pode escolher um mix diferente entre os fatores de produção capital e trabalho. Para essa alocação, também é utilizada uma função de agregação CES, com elasticidade substituição $\sigma^{1PRIM}_i$. Assim, pode-se definir a demanda (em variações) por trabalho e capital na indústria $i$ como:

$$\hat{\text{X1LAB}}_i = \left(\frac{\hat{\text{P1LAB}}}{\hat{\text{P1PRIM}}_i}\right)^{-\sigma_i^{\text{1PRIM}}}\hat{\text{X1PRIM}}_i, \quad i \in \text{IND} \quad \text{e}$$
$$\hat{\text{X1CAP}}_i = \left(\frac{\hat{\text{P1CAP}}_i}{\hat{\text{P1PRIM}}_i}\right)^{-\sigma_i^{\text{1PRIM}}}\hat{\text{X1PRIM}}_i, \quad i \in \text{IND},$$
em que $\hat{\text{X1LAB}}_i$ é a variação da demanda por trabalho pela indústria $i$, $\hat{\text{P1LAB}}$ é o salário nominal, $\hat{\text{P1PRIM}}_i$ é a variação do índice de preços dos fatores primários para a indústria $i$, $\hat{\text{X1PRIM}}_i$ é a variação da demanda por fatores primários da indústria $i$, $\hat{\text{X1CAP}}_i$ é a variação da demanda por capital pela indústria $i$ e $\hat{\text{P1CAP}}_i$ é a remuneração do capital na indústria $i$.

A variável $\hat{\text{P1PRIM}}_i$ é calculada da seguinte forma:
$$\hat{\text{P1PRIM}}_i = \text{SHAREPRIM}_{\text{lab},i}\times \hat{\text{P1LAB}} + \text{SHAREPRIM}_{\text{cap},i}\times \hat{\text{P1CAP}}_i$$

Note que o índice da $i$ foi retirado de $\hat{\text{P1LAB}}$ (salário), pois no fechamento adotado assume-se que o trabalho tem perfeita mobilidade entre os setores. Diferentemente, o capital será assumido fixo dentro de cada indústria. Ademais, consideraremos que no curto prazo a variação do salário real ($\hat{\text{RW}}$) é fixa (exógena) e a variação do nível de emprego ($\hat{L}$) é endógena, o que implica que $\hat{\text{P1LAB}}$ deve variar na mesma proporção de $\hat{\text{P3TOT}}$. Então, temos mais duas equações:
$$\hat{\text{P1LAB}} = \hat{\text{RW}} \times \hat{\text{P3TOT}}$$
$$\hat{L} = \sum_{i \in \text{IND}} \text{SHARE LAB}_i \times \hat{\text{X1LAB}}_i$$ 

Primeiro, definimos os parâmetros desse bloco.

```{r}
SIGMA1PRIM <- read_csv(
  file = "../dados/minimal.csv",
  skip = 200,
  n_max = 7,
  col_types = 'cd'
)

params[["SIGMA1PRIM"]] <- create_param(
  value = SIGMA1PRIM,
  indexes = sets["IND"],
  desc = "Elasticidade de subsituição entre os fatores de produção"
)

FAC <- read_csv(
  file = "../dados/minimal.csv",
  skip = 157,
  n_max = 14,
  col_types = 'ccd'
)

SHAREPRIM <- FAC %>% 
  group_by(IND) %>% 
  mutate(SHAREPRIM = Value/sum(Value)) %>% 
  select(FAC, IND, SHAREPRIM)

params[["SHAREPRIM"]] <- create_param(
  value = SHAREPRIM,
  indexes = sets[c("FAC", "IND")],
  desc = "Part. de cada fator no uso do fator primário por indústria"
)

SHARELAB <- FAC %>%
  filter(FAC == "Labour") %>% 
  mutate(SHARELAB = Value/sum(Value)) %>% 
  select(IND, SHARELAB)

params[["SHARELAB"]] <- create_param(
  value = SHARELAB,
  indexes = sets["IND"],
  desc = "Part. de cada indústria no uso do fator trabalho"
)
```


```{r}
params[["RW"]] <- create_param(
  value = 1,
  indexes = "rw",
  desc = 'Variação no salário real'
)

# O capital é fixo na indústria (exógeno)
params[["X1CAP"]] <- create_param(
  value = 1,
  indexes = sets["IND"],
  desc = "Variação no uso de capital por indústria"
)
```

Na sequência, definimos as variáveis.

```{r}
variables[["x1lab"]] <- create_variable(
  value = 1,
  indexes = sets[c('IND')],
  type = "defined",
  desc = "Variação no emprego por indústria"
)
```


```{r}
variables[["p1lab"]] <- create_variable(
  value = 1,
  indexes = "p1lab",
  type = "defined",
  desc = "Variação no salário nominal"
)

variables[["p1cap"]] <- create_variable(
  value = 1,
  indexes = sets['IND'],
  type = "defined",
  desc = "Variação na remuneração do capital por indústria i"
)

variables[["p1prim"]] <- create_variable(
  value = 1,
  indexes = sets['IND'],
  type = "defined",
  desc = "Variação no índice de preço do fator primário composto por indústria i"
)

variables[["l"]] <- create_variable(
  value = 1,
  indexes = "emprego",
  type = "defined",
  desc = "Variação no emprego total"
)
```

Por fim, vamos definir as equações^[A equação para a remuneração do capital foi invertida para isolar $\hat{\text{P1CAP}}_i$.].

```{r}
equations[["E_x1lab"]] <- create_equation(
  'x1lab[i] = x1prim[i]*(p1lab/p1prim[i])^(-SIGMA1PRIM[i])',
  indexes = c('i in IND'),
  type = "defining",
  desc = "Variação no emprego por indústria"
)
```


```{r}
equations[["E_p1lab"]] <- create_equation(
  'p1lab = RW * p3tot',
  type = "defining",
  desc = "Variação no salário nominal"
)

equations[["E_p1cap"]] <- create_equation(
  'p1cap[i] = p1prim[i] * (x1cap[i]/x1prim[i])^(-1/SIGMA1PRIM[i])',
  type = "defining",
  desc = "Variação no salário nominal"
)

equations[["E_p1prim"]] <- create_equation(
  'p1prim[i] = SHAREPRIM["Labour",i] * p1lab + 
               SHAREPRIM["Capital",i] * p1cap[i]',
  indexes = c('i in IND'),
  type = "defining",
  desc = "Variação no índice de preço do fator primário para indústria i"
)

equations[["E_l"]] <- create_equation(
  'l = sum(SHARELAB * x1lab)',
  type = "defining",
  desc = "Variação no emprego total"
)
```

### Equilíbrios nos Mercados de Bens



